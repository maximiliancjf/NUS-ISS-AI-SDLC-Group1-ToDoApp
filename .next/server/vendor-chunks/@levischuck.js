"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@levischuck";
exports.ids = ["vendor-chunks/@levischuck"];
exports.modules = {

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js":
/*!*************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* binding */ CBORTag),\n/* harmony export */   decodeCBOR: () => (/* binding */ decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* binding */ decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* binding */ encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor_internal.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\");\n\n/**\n * A value which is wrapped with a CBOR Tag.\n * Several tags are registered with defined meanings like 0 for a date string.\n * These meanings are **not interpreted** when decoded or encoded.\n *\n * This class is an immutable record.\n * If the tag number or value needs to change, then construct a new tag\n */\nclass CBORTag {\n    /**\n     * Wrap a value with a tag number.\n     * When encoded, this tag will be attached to the value.\n     *\n     * @param tag Tag number\n     * @param value Wrapped value\n     */\n    constructor(tag, value) {\n        Object.defineProperty(this, \"tagId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tagValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tagId = tag;\n        this.tagValue = value;\n    }\n    /**\n     * Read the tag number\n     */\n    get tag() {\n        return this.tagId;\n    }\n    /**\n     * Read the value\n     */\n    get value() {\n        return this.tagValue;\n    }\n}\nfunction decodeUnsignedInteger(data, argument, index) {\n    return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n}\nfunction decodeNegativeInteger(data, argument, index) {\n    const [value, length] = decodeUnsignedInteger(data, argument, index);\n    return [-value - 1, length];\n}\nfunction decodeByteString(data, argument, index) {\n    const [lengthValue, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const dataStartIndex = index + lengthConsumed;\n    return [\n        new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),\n        lengthConsumed + lengthValue,\n    ];\n}\nconst TEXT_DECODER = new TextDecoder();\nfunction decodeString(data, argument, index) {\n    const [value, length] = decodeByteString(data, argument, index);\n    return [TEXT_DECODER.decode(value), length];\n}\nfunction decodeArray(data, argument, index) {\n    if (argument === 0) {\n        return [[], 1];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const value = [];\n    for (let i = 0; i < length; i++) {\n        const remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(\"array is not supported or well formed\");\n        }\n        const [decodedValue, consumed] = decodeNext(data, index + consumedLength);\n        value.push(decodedValue);\n        consumedLength += consumed;\n    }\n    return [value, consumedLength];\n}\nconst MAP_ERROR = \"Map is not supported or well formed\";\nfunction decodeMap(data, argument, index) {\n    if (argument === 0) {\n        return [new Map(), 1];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const result = new Map();\n    for (let i = 0; i < length; i++) {\n        let remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load key\n        const [key, keyConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += keyConsumed;\n        remainingDataLength -= keyConsumed;\n        // Check that there's enough to have a value\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Technically CBOR maps can have any type as the key, and so can JS Maps\n        // However, JS Maps can only reference such keys as references which would\n        // require key iteration and pattern matching.\n        // For simplicity, since such keys are not in use with WebAuthn, this\n        // capability is not implemented and the types are restricted to strings\n        // and numbers.\n        if (typeof key !== \"string\" && typeof key !== \"number\") {\n            throw new Error(MAP_ERROR);\n        }\n        // CBOR Maps are not well formed if there are duplicate keys\n        if (result.has(key)) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load value\n        const [value, valueConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += valueConsumed;\n        result.set(key, value);\n    }\n    return [result, consumedLength];\n}\nfunction decodeFloat16(data, index) {\n    if (index + 3 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 16\");\n    }\n    // Skip the first byte\n    const result = data.getUint16(index + 1, false);\n    // A minimal selection of supported values\n    if (result == 0x7c00) {\n        return [Infinity, 3];\n    }\n    else if (result == 0x7e00) {\n        return [NaN, 3];\n    }\n    else if (result == 0xfc00) {\n        return [-Infinity, 3];\n    }\n    throw new Error(\"Float16 data is unsupported\");\n}\nfunction decodeFloat32(data, index) {\n    if (index + 5 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 32\");\n    }\n    // Skip the first byte\n    const result = data.getFloat32(index + 1, false);\n    // First byte + 4 byte float\n    return [result, 5];\n}\nfunction decodeFloat64(data, index) {\n    if (index + 9 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 64\");\n    }\n    // Skip the first byte\n    const result = data.getFloat64(index + 1, false);\n    // First byte + 8 byte float\n    return [result, 9];\n}\nfunction decodeTag(data, argument, index) {\n    const [tag, tagBytes] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const [value, valueBytes] = decodeNext(data, index + tagBytes);\n    return [new CBORTag(tag, value), tagBytes + valueBytes];\n}\nfunction decodeNext(data, index) {\n    if (index >= data.byteLength) {\n        throw new Error(\"CBOR stream ended before tag value\");\n    }\n    const byte = data.getUint8(index);\n    const majorType = byte >> 5;\n    const argument = byte & 0x1f;\n    switch (majorType) {\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER: {\n            return decodeUnsignedInteger(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER: {\n            return decodeNegativeInteger(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING: {\n            return decodeByteString(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING: {\n            return decodeString(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY: {\n            return decodeArray(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP: {\n            return decodeMap(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG: {\n            return decodeTag(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_SIMPLE_OR_FLOAT: {\n            switch (argument) {\n                case 20:\n                    return [false, 1];\n                case 21:\n                    return [true, 1];\n                case 22:\n                    return [null, 1];\n                case 23:\n                    return [undefined, 1];\n                // 24: Simple value (value 32..255 in following byte)\n                case 25: // IEEE 754 Half-Precision Float (16 bits follow)\n                    return decodeFloat16(data, index);\n                case 26: // IEEE 754 Single-Precision Float (32 bits follow)\n                    return decodeFloat32(data, index);\n                case 27: // IEEE 754 Double-Precision Float (64 bits follow)\n                    return decodeFloat64(data, index);\n                // 28-30: Reserved, not well-formed in the present document\n                // 31: \"break\" stop code for indefinite-length items\n            }\n        }\n    }\n    throw new Error(`Unsupported or not well formed at ${index}`);\n}\nfunction encodeSimple(data) {\n    if (data === true) {\n        return 0xf5;\n    }\n    else if (data === false) {\n        return 0xf4;\n    }\n    else if (data === null) {\n        return 0xf6;\n    }\n    // Else undefined\n    return 0xf7;\n}\nfunction encodeFloat(data) {\n    if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {\n        // Float32\n        const output = new Uint8Array(5);\n        output[0] = 0xfa;\n        const view = new DataView(output.buffer);\n        view.setFloat32(1, data, false);\n        return output;\n    }\n    else {\n        // Float64\n        const output = new Uint8Array(9);\n        output[0] = 0xfb;\n        const view = new DataView(output.buffer);\n        view.setFloat64(1, data, false);\n        return output;\n    }\n}\nfunction encodeNumber(data) {\n    if (typeof data == \"number\") {\n        if (Number.isSafeInteger(data)) {\n            // Encode integer\n            if (data < 0) {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));\n            }\n            else {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n            }\n        }\n        return [encodeFloat(data)];\n    }\n    else {\n        if (data < 0n) {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);\n        }\n        else {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n        }\n    }\n}\nconst ENCODER = new TextEncoder();\nfunction encodeString(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING, data.length));\n    output.push(ENCODER.encode(data));\n}\nfunction encodeBytes(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING, data.length));\n    output.push(data);\n}\nfunction encodeArray(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY, data.length));\n    for (const element of data) {\n        encodePartialCBOR(element, output);\n    }\n}\nfunction encodeMap(data, output) {\n    output.push(new Uint8Array((0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP, data.size)));\n    for (const [key, value] of data.entries()) {\n        encodePartialCBOR(key, output);\n        encodePartialCBOR(value, output);\n    }\n}\nfunction encodeTag(tag, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG, tag.tag));\n    encodePartialCBOR(tag.value, output);\n}\nfunction encodePartialCBOR(data, output) {\n    if (typeof data == \"boolean\" || data === null || data == undefined) {\n        output.push(encodeSimple(data));\n        return;\n    }\n    if (typeof data == \"number\" || typeof data == \"bigint\") {\n        output.push(...encodeNumber(data));\n        return;\n    }\n    if (typeof data == \"string\") {\n        encodeString(data, output);\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        encodeBytes(data, output);\n        return;\n    }\n    if (Array.isArray(data)) {\n        encodeArray(data, output);\n        return;\n    }\n    if (data instanceof Map) {\n        encodeMap(data, output);\n        return;\n    }\n    if (data instanceof CBORTag) {\n        encodeTag(data, output);\n        return;\n    }\n    throw new Error(\"Not implemented\");\n}\n/**\n * Like {decodeCBOR}, but the length of the data is unknown and there is likely\n * more -- possibly unrelated non-CBOR -- data afterwards.\n *\n * Examples:\n *\n * ```ts\n * import {decodePartialCBOR} from './cbor.ts'\n * decodePartialCBOR(new Uint8Array([1, 2, 245, 3, 4]), 2)\n * // returns [true, 1]\n * // It did not decode the leading [1, 2] or trailing [3, 4]\n * ```\n *\n * @param data a data stream to read data from\n * @param index where to start reading in the data stream\n * @returns a tuple of the value followed by bytes read.\n * @throws {Error}\n *   When the data stream ends early or the CBOR data is not well formed\n */\nfunction decodePartialCBOR(data, index) {\n    if (data.byteLength === 0 || data.byteLength <= index || index < 0) {\n        throw new Error(\"No data\");\n    }\n    if (data instanceof Uint8Array) {\n        return decodeNext(new DataView(data.buffer), index);\n    }\n    else if (data instanceof ArrayBuffer) {\n        return decodeNext(new DataView(data), index);\n    }\n    // otherwise, it is a data view\n    return decodeNext(data, index);\n}\n/**\n * Decode CBOR data from a binary stream\n *\n * The entire data stream from [0, length) will be consumed.\n * If you require a partial decoding, see {decodePartialCBOR}.\n *\n * Examples:\n *\n * ```ts\n * import {decodeCBOR, CBORTag, CBORType} from './cbor.ts'\n * decodeCBOR(new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101]));\n * // returns new Map<string | number, CBORType>([\n * //   [\"key\", \"value\"],\n * //   [1, \"another value\"]\n * // ]);\n *\n * const taggedItem = new Uint8Array([217, 4, 210, 101, 104, 101, 108, 108, 111]);\n * decodeCBOR(new DataView(taggedItem.buffer))\n * // returns new CBORTag(1234, \"hello\")\n * ```\n *\n * @param data a data stream, multiple types are supported\n * @returns\n */\nfunction decodeCBOR(data) {\n    const [value, length] = decodePartialCBOR(data, 0);\n    if (length !== data.byteLength) {\n        throw new Error(`Data was decoded, but the whole stream was not processed ${length} != ${data.byteLength}`);\n    }\n    return value;\n}\n/**\n * Encode a supported structure to a CBOR byte string.\n *\n * Example:\n *\n * ```ts\n * import {encodeCBOR, CBORType, CBORTag} from './cbor.ts'\n * encodeCBOR(new Map<string | number, CBORType>([\n *   [\"key\", \"value\"],\n *   [1, \"another value\"]\n * ]));\n * // returns new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32 118, 97, 108, 117, 101])\n *\n * encodeCBOR(new CBORTag(1234, \"hello\"))\n * // returns new UInt8Array([217, 4, 210, 101, 104, 101, 108, 108, 111])\n * ```\n *\n * @param data Data to encode\n * @returns A byte string as a Uint8Array\n * @throws Error\n *   if unsupported data is found during encoding\n */\nfunction encodeCBOR(data) {\n    const results = [];\n    encodePartialCBOR(data, results);\n    let length = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            length += 1;\n        }\n        else {\n            length += result.length;\n        }\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            output[index] = result;\n            index += 1;\n        }\n        else {\n            output.set(result, index);\n            index += result.length;\n        }\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0RBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtEQUFZO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0RBQVk7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZHlcXERlc2t0b3BcXGdpdGh1YmNvcGlsb3RcXE5VUy1JU1MtQUktU0RMQy1Hcm91cDEtVG9Eb0FwcFxcbm9kZV9tb2R1bGVzXFxAbGV2aXNjaHVja1xcdGlueS1jYm9yXFxlc21cXGNib3JcXGNib3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVjb2RlTGVuZ3RoLCBlbmNvZGVMZW5ndGgsIE1BSk9SX1RZUEVfQVJSQVksIE1BSk9SX1RZUEVfQllURV9TVFJJTkcsIE1BSk9SX1RZUEVfTUFQLCBNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIsIE1BSk9SX1RZUEVfU0lNUExFX09SX0ZMT0FULCBNQUpPUl9UWVBFX1RBRywgTUFKT1JfVFlQRV9URVhUX1NUUklORywgTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSLCB9IGZyb20gXCIuL2Nib3JfaW50ZXJuYWwuanNcIjtcbi8qKlxuICogQSB2YWx1ZSB3aGljaCBpcyB3cmFwcGVkIHdpdGggYSBDQk9SIFRhZy5cbiAqIFNldmVyYWwgdGFncyBhcmUgcmVnaXN0ZXJlZCB3aXRoIGRlZmluZWQgbWVhbmluZ3MgbGlrZSAwIGZvciBhIGRhdGUgc3RyaW5nLlxuICogVGhlc2UgbWVhbmluZ3MgYXJlICoqbm90IGludGVycHJldGVkKiogd2hlbiBkZWNvZGVkIG9yIGVuY29kZWQuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBhbiBpbW11dGFibGUgcmVjb3JkLlxuICogSWYgdGhlIHRhZyBudW1iZXIgb3IgdmFsdWUgbmVlZHMgdG8gY2hhbmdlLCB0aGVuIGNvbnN0cnVjdCBhIG5ldyB0YWdcbiAqL1xuZXhwb3J0IGNsYXNzIENCT1JUYWcge1xuICAgIC8qKlxuICAgICAqIFdyYXAgYSB2YWx1ZSB3aXRoIGEgdGFnIG51bWJlci5cbiAgICAgKiBXaGVuIGVuY29kZWQsIHRoaXMgdGFnIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhZyBUYWcgbnVtYmVyXG4gICAgICogQHBhcmFtIHZhbHVlIFdyYXBwZWQgdmFsdWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YWcsIHZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ0lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ1ZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGFnSWQgPSB0YWc7XG4gICAgICAgIHRoaXMudGFnVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgdGFnIG51bWJlclxuICAgICAqL1xuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnVmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb2RlVW5zaWduZWRJbnRlZ2VyKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIHJldHVybiBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGRlY29kZU5lZ2F0aXZlSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBjb25zdCBbdmFsdWUsIGxlbmd0aF0gPSBkZWNvZGVVbnNpZ25lZEludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICByZXR1cm4gWy12YWx1ZSAtIDEsIGxlbmd0aF07XG59XG5mdW5jdGlvbiBkZWNvZGVCeXRlU3RyaW5nKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGNvbnN0IFtsZW5ndGhWYWx1ZSwgbGVuZ3RoQ29uc3VtZWRdID0gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgY29uc3QgZGF0YVN0YXJ0SW5kZXggPSBpbmRleCArIGxlbmd0aENvbnN1bWVkO1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLnNsaWNlKGRhdGFTdGFydEluZGV4LCBkYXRhU3RhcnRJbmRleCArIGxlbmd0aFZhbHVlKSksXG4gICAgICAgIGxlbmd0aENvbnN1bWVkICsgbGVuZ3RoVmFsdWUsXG4gICAgXTtcbn1cbmNvbnN0IFRFWFRfREVDT0RFUiA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGNvbnN0IFt2YWx1ZSwgbGVuZ3RoXSA9IGRlY29kZUJ5dGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICByZXR1cm4gW1RFWFRfREVDT0RFUi5kZWNvZGUodmFsdWUpLCBsZW5ndGhdO1xufVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgaWYgKGFyZ3VtZW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbW10sIDFdO1xuICAgIH1cbiAgICBjb25zdCBbbGVuZ3RoLCBsZW5ndGhDb25zdW1lZF0gPSBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICBsZXQgY29uc3VtZWRMZW5ndGggPSBsZW5ndGhDb25zdW1lZDtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nRGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIGluZGV4IC0gY29uc3VtZWRMZW5ndGg7XG4gICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIG5vdCBzdXBwb3J0ZWQgb3Igd2VsbCBmb3JtZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2RlY29kZWRWYWx1ZSwgY29uc3VtZWRdID0gZGVjb2RlTmV4dChkYXRhLCBpbmRleCArIGNvbnN1bWVkTGVuZ3RoKTtcbiAgICAgICAgdmFsdWUucHVzaChkZWNvZGVkVmFsdWUpO1xuICAgICAgICBjb25zdW1lZExlbmd0aCArPSBjb25zdW1lZDtcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgY29uc3VtZWRMZW5ndGhdO1xufVxuY29uc3QgTUFQX0VSUk9SID0gXCJNYXAgaXMgbm90IHN1cHBvcnRlZCBvciB3ZWxsIGZvcm1lZFwiO1xuZnVuY3Rpb24gZGVjb2RlTWFwKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGlmIChhcmd1bWVudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW25ldyBNYXAoKSwgMV07XG4gICAgfVxuICAgIGNvbnN0IFtsZW5ndGgsIGxlbmd0aENvbnN1bWVkXSA9IGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIGxldCBjb25zdW1lZExlbmd0aCA9IGxlbmd0aENvbnN1bWVkO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZW1haW5pbmdEYXRhTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIC0gaW5kZXggLSBjb25zdW1lZExlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BUF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCBrZXlcbiAgICAgICAgY29uc3QgW2tleSwga2V5Q29uc3VtZWRdID0gZGVjb2RlTmV4dChkYXRhLCBpbmRleCArIGNvbnN1bWVkTGVuZ3RoKTtcbiAgICAgICAgY29uc3VtZWRMZW5ndGggKz0ga2V5Q29uc3VtZWQ7XG4gICAgICAgIHJlbWFpbmluZ0RhdGFMZW5ndGggLT0ga2V5Q29uc3VtZWQ7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUncyBlbm91Z2ggdG8gaGF2ZSBhIHZhbHVlXG4gICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQVBfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlY2huaWNhbGx5IENCT1IgbWFwcyBjYW4gaGF2ZSBhbnkgdHlwZSBhcyB0aGUga2V5LCBhbmQgc28gY2FuIEpTIE1hcHNcbiAgICAgICAgLy8gSG93ZXZlciwgSlMgTWFwcyBjYW4gb25seSByZWZlcmVuY2Ugc3VjaCBrZXlzIGFzIHJlZmVyZW5jZXMgd2hpY2ggd291bGRcbiAgICAgICAgLy8gcmVxdWlyZSBrZXkgaXRlcmF0aW9uIGFuZCBwYXR0ZXJuIG1hdGNoaW5nLlxuICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgc2luY2Ugc3VjaCBrZXlzIGFyZSBub3QgaW4gdXNlIHdpdGggV2ViQXV0aG4sIHRoaXNcbiAgICAgICAgLy8gY2FwYWJpbGl0eSBpcyBub3QgaW1wbGVtZW50ZWQgYW5kIHRoZSB0eXBlcyBhcmUgcmVzdHJpY3RlZCB0byBzdHJpbmdzXG4gICAgICAgIC8vIGFuZCBudW1iZXJzLlxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFQX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDQk9SIE1hcHMgYXJlIG5vdCB3ZWxsIGZvcm1lZCBpZiB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXNcbiAgICAgICAgaWYgKHJlc3VsdC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BUF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCB2YWx1ZVxuICAgICAgICBjb25zdCBbdmFsdWUsIHZhbHVlQ29uc3VtZWRdID0gZGVjb2RlTmV4dChkYXRhLCBpbmRleCArIGNvbnN1bWVkTGVuZ3RoKTtcbiAgICAgICAgY29uc3VtZWRMZW5ndGggKz0gdmFsdWVDb25zdW1lZDtcbiAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHQsIGNvbnN1bWVkTGVuZ3RoXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUZsb2F0MTYoZGF0YSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggKyAzID4gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1Igc3RyZWFtIGVuZGVkIGJlZm9yZSBlbmQgb2YgRmxvYXQgMTZcIik7XG4gICAgfVxuICAgIC8vIFNraXAgdGhlIGZpcnN0IGJ5dGVcbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLmdldFVpbnQxNihpbmRleCArIDEsIGZhbHNlKTtcbiAgICAvLyBBIG1pbmltYWwgc2VsZWN0aW9uIG9mIHN1cHBvcnRlZCB2YWx1ZXNcbiAgICBpZiAocmVzdWx0ID09IDB4N2MwMCkge1xuICAgICAgICByZXR1cm4gW0luZmluaXR5LCAzXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ID09IDB4N2UwMCkge1xuICAgICAgICByZXR1cm4gW05hTiwgM107XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCA9PSAweGZjMDApIHtcbiAgICAgICAgcmV0dXJuIFstSW5maW5pdHksIDNdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGbG9hdDE2IGRhdGEgaXMgdW5zdXBwb3J0ZWRcIik7XG59XG5mdW5jdGlvbiBkZWNvZGVGbG9hdDMyKGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICsgNSA+IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIHN0cmVhbSBlbmRlZCBiZWZvcmUgZW5kIG9mIEZsb2F0IDMyXCIpO1xuICAgIH1cbiAgICAvLyBTa2lwIHRoZSBmaXJzdCBieXRlXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YS5nZXRGbG9hdDMyKGluZGV4ICsgMSwgZmFsc2UpO1xuICAgIC8vIEZpcnN0IGJ5dGUgKyA0IGJ5dGUgZmxvYXRcbiAgICByZXR1cm4gW3Jlc3VsdCwgNV07XG59XG5mdW5jdGlvbiBkZWNvZGVGbG9hdDY0KGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICsgOSA+IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIHN0cmVhbSBlbmRlZCBiZWZvcmUgZW5kIG9mIEZsb2F0IDY0XCIpO1xuICAgIH1cbiAgICAvLyBTa2lwIHRoZSBmaXJzdCBieXRlXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YS5nZXRGbG9hdDY0KGluZGV4ICsgMSwgZmFsc2UpO1xuICAgIC8vIEZpcnN0IGJ5dGUgKyA4IGJ5dGUgZmxvYXRcbiAgICByZXR1cm4gW3Jlc3VsdCwgOV07XG59XG5mdW5jdGlvbiBkZWNvZGVUYWcoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgY29uc3QgW3RhZywgdGFnQnl0ZXNdID0gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgY29uc3QgW3ZhbHVlLCB2YWx1ZUJ5dGVzXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyB0YWdCeXRlcyk7XG4gICAgcmV0dXJuIFtuZXcgQ0JPUlRhZyh0YWcsIHZhbHVlKSwgdGFnQnl0ZXMgKyB2YWx1ZUJ5dGVzXTtcbn1cbmZ1bmN0aW9uIGRlY29kZU5leHQoZGF0YSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1Igc3RyZWFtIGVuZGVkIGJlZm9yZSB0YWcgdmFsdWVcIik7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGUgPSBkYXRhLmdldFVpbnQ4KGluZGV4KTtcbiAgICBjb25zdCBtYWpvclR5cGUgPSBieXRlID4+IDU7XG4gICAgY29uc3QgYXJndW1lbnQgPSBieXRlICYgMHgxZjtcbiAgICBzd2l0Y2ggKG1ham9yVHlwZSkge1xuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfVU5TSUdORURfSU5URUdFUjoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVuc2lnbmVkSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlTmVnYXRpdmVJbnRlZ2VyKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX0JZVEVfU1RSSU5HOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlQnl0ZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9URVhUX1NUUklORzoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9BUlJBWToge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUFycmF5KGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX01BUDoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU1hcChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9UQUc6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVUYWcoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfU0lNUExFX09SX0ZMT0FUOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW251bGwsIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAxXTtcbiAgICAgICAgICAgICAgICAvLyAyNDogU2ltcGxlIHZhbHVlICh2YWx1ZSAzMi4uMjU1IGluIGZvbGxvd2luZyBieXRlKVxuICAgICAgICAgICAgICAgIGNhc2UgMjU6IC8vIElFRUUgNzU0IEhhbGYtUHJlY2lzaW9uIEZsb2F0ICgxNiBiaXRzIGZvbGxvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZsb2F0MTYoZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY6IC8vIElFRUUgNzU0IFNpbmdsZS1QcmVjaXNpb24gRmxvYXQgKDMyIGJpdHMgZm9sbG93KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRmxvYXQzMihkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gSUVFRSA3NTQgRG91YmxlLVByZWNpc2lvbiBGbG9hdCAoNjQgYml0cyBmb2xsb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGbG9hdDY0KGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyAyOC0zMDogUmVzZXJ2ZWQsIG5vdCB3ZWxsLWZvcm1lZCBpbiB0aGUgcHJlc2VudCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIDMxOiBcImJyZWFrXCIgc3RvcCBjb2RlIGZvciBpbmRlZmluaXRlLWxlbmd0aCBpdGVtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3Igbm90IHdlbGwgZm9ybWVkIGF0ICR7aW5kZXh9YCk7XG59XG5mdW5jdGlvbiBlbmNvZGVTaW1wbGUoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAweGY1O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gMHhmNDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMHhmNjtcbiAgICB9XG4gICAgLy8gRWxzZSB1bmRlZmluZWRcbiAgICByZXR1cm4gMHhmNztcbn1cbmZ1bmN0aW9uIGVuY29kZUZsb2F0KGRhdGEpIHtcbiAgICBpZiAoTWF0aC5mcm91bmQoZGF0YSkgPT0gZGF0YSB8fCAhTnVtYmVyLmlzRmluaXRlKGRhdGEpIHx8IE51bWJlci5pc05hTihkYXRhKSkge1xuICAgICAgICAvLyBGbG9hdDMyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KDUpO1xuICAgICAgICBvdXRwdXRbMF0gPSAweGZhO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG91dHB1dC5idWZmZXIpO1xuICAgICAgICB2aWV3LnNldEZsb2F0MzIoMSwgZGF0YSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRmxvYXQ2NFxuICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheSg5KTtcbiAgICAgICAgb3V0cHV0WzBdID0gMHhmYjtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXQuYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRGbG9hdDY0KDEsIGRhdGEsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVOdW1iZXIoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihkYXRhKSkge1xuICAgICAgICAgICAgLy8gRW5jb2RlIGludGVnZXJcbiAgICAgICAgICAgIGlmIChkYXRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSLCBNYXRoLmFicyhkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfVU5TSUdORURfSU5URUdFUiwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtlbmNvZGVGbG9hdChkYXRhKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZGF0YSA8IDBuKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiwgZGF0YSAqIC0xbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfVU5TSUdORURfSU5URUdFUiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBFTkNPREVSID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcoZGF0YSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfVEVYVF9TVFJJTkcsIGRhdGEubGVuZ3RoKSk7XG4gICAgb3V0cHV0LnB1c2goRU5DT0RFUi5lbmNvZGUoZGF0YSkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfQllURV9TVFJJTkcsIGRhdGEubGVuZ3RoKSk7XG4gICAgb3V0cHV0LnB1c2goZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGVBcnJheShkYXRhLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQucHVzaCguLi5lbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9BUlJBWSwgZGF0YS5sZW5ndGgpKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSkge1xuICAgICAgICBlbmNvZGVQYXJ0aWFsQ0JPUihlbGVtZW50LCBvdXRwdXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuY29kZU1hcChkYXRhLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQucHVzaChuZXcgVWludDhBcnJheShlbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9NQVAsIGRhdGEuc2l6ZSkpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgICBlbmNvZGVQYXJ0aWFsQ0JPUihrZXksIG91dHB1dCk7XG4gICAgICAgIGVuY29kZVBhcnRpYWxDQk9SKHZhbHVlLCBvdXRwdXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuY29kZVRhZyh0YWcsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1RBRywgdGFnLnRhZykpO1xuICAgIGVuY29kZVBhcnRpYWxDQk9SKHRhZy52YWx1ZSwgb3V0cHV0KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhcnRpYWxDQk9SKGRhdGEsIG91dHB1dCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcImJvb2xlYW5cIiB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGVuY29kZVNpbXBsZShkYXRhKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRhdGEgPT0gXCJiaWdpbnRcIikge1xuICAgICAgICBvdXRwdXQucHVzaCguLi5lbmNvZGVOdW1iZXIoZGF0YSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGVuY29kZVN0cmluZyhkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBlbmNvZGVCeXRlcyhkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGVuY29kZUFycmF5KGRhdGEsIG91dHB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZW5jb2RlTWFwKGRhdGEsIG91dHB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDQk9SVGFnKSB7XG4gICAgICAgIGVuY29kZVRhZyhkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cbi8qKlxuICogTGlrZSB7ZGVjb2RlQ0JPUn0sIGJ1dCB0aGUgbGVuZ3RoIG9mIHRoZSBkYXRhIGlzIHVua25vd24gYW5kIHRoZXJlIGlzIGxpa2VseVxuICogbW9yZSAtLSBwb3NzaWJseSB1bnJlbGF0ZWQgbm9uLUNCT1IgLS0gZGF0YSBhZnRlcndhcmRzLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2RlY29kZVBhcnRpYWxDQk9SfSBmcm9tICcuL2Nib3IudHMnXG4gKiBkZWNvZGVQYXJ0aWFsQ0JPUihuZXcgVWludDhBcnJheShbMSwgMiwgMjQ1LCAzLCA0XSksIDIpXG4gKiAvLyByZXR1cm5zIFt0cnVlLCAxXVxuICogLy8gSXQgZGlkIG5vdCBkZWNvZGUgdGhlIGxlYWRpbmcgWzEsIDJdIG9yIHRyYWlsaW5nIFszLCA0XVxuICogYGBgXG4gKlxuICogQHBhcmFtIGRhdGEgYSBkYXRhIHN0cmVhbSB0byByZWFkIGRhdGEgZnJvbVxuICogQHBhcmFtIGluZGV4IHdoZXJlIHRvIHN0YXJ0IHJlYWRpbmcgaW4gdGhlIGRhdGEgc3RyZWFtXG4gKiBAcmV0dXJucyBhIHR1cGxlIG9mIHRoZSB2YWx1ZSBmb2xsb3dlZCBieSBieXRlcyByZWFkLlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgIFdoZW4gdGhlIGRhdGEgc3RyZWFtIGVuZHMgZWFybHkgb3IgdGhlIENCT1IgZGF0YSBpcyBub3Qgd2VsbCBmb3JtZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVBhcnRpYWxDQk9SKGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA9PT0gMCB8fCBkYXRhLmJ5dGVMZW5ndGggPD0gaW5kZXggfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGFcIik7XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlTmV4dChuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIpLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZGVjb2RlTmV4dChuZXcgRGF0YVZpZXcoZGF0YSksIGluZGV4KTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCBpdCBpcyBhIGRhdGEgdmlld1xuICAgIHJldHVybiBkZWNvZGVOZXh0KGRhdGEsIGluZGV4KTtcbn1cbi8qKlxuICogRGVjb2RlIENCT1IgZGF0YSBmcm9tIGEgYmluYXJ5IHN0cmVhbVxuICpcbiAqIFRoZSBlbnRpcmUgZGF0YSBzdHJlYW0gZnJvbSBbMCwgbGVuZ3RoKSB3aWxsIGJlIGNvbnN1bWVkLlxuICogSWYgeW91IHJlcXVpcmUgYSBwYXJ0aWFsIGRlY29kaW5nLCBzZWUge2RlY29kZVBhcnRpYWxDQk9SfS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtkZWNvZGVDQk9SLCBDQk9SVGFnLCBDQk9SVHlwZX0gZnJvbSAnLi9jYm9yLnRzJ1xuICogZGVjb2RlQ0JPUihuZXcgVWludDhBcnJheShbMTYyLCA5OSwgMTA3LCAxMDEsIDEyMSwgMTAxLCAxMTgsIDk3LCAxMDgsIDExNywgMTAxLCAxLCAxMDksIDk3LCAxMTAsIDExMSwgMTE2LCAxMDQsIDEwMSwgMTE0LCAzMiwgMTE4LCA5NywgMTA4LCAxMTcsIDEwMV0pKTtcbiAqIC8vIHJldHVybnMgbmV3IE1hcDxzdHJpbmcgfCBudW1iZXIsIENCT1JUeXBlPihbXG4gKiAvLyAgIFtcImtleVwiLCBcInZhbHVlXCJdLFxuICogLy8gICBbMSwgXCJhbm90aGVyIHZhbHVlXCJdXG4gKiAvLyBdKTtcbiAqXG4gKiBjb25zdCB0YWdnZWRJdGVtID0gbmV3IFVpbnQ4QXJyYXkoWzIxNywgNCwgMjEwLCAxMDEsIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSk7XG4gKiBkZWNvZGVDQk9SKG5ldyBEYXRhVmlldyh0YWdnZWRJdGVtLmJ1ZmZlcikpXG4gKiAvLyByZXR1cm5zIG5ldyBDQk9SVGFnKDEyMzQsIFwiaGVsbG9cIilcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIGEgZGF0YSBzdHJlYW0sIG11bHRpcGxlIHR5cGVzIGFyZSBzdXBwb3J0ZWRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVDQk9SKGRhdGEpIHtcbiAgICBjb25zdCBbdmFsdWUsIGxlbmd0aF0gPSBkZWNvZGVQYXJ0aWFsQ0JPUihkYXRhLCAwKTtcbiAgICBpZiAobGVuZ3RoICE9PSBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIHdhcyBkZWNvZGVkLCBidXQgdGhlIHdob2xlIHN0cmVhbSB3YXMgbm90IHByb2Nlc3NlZCAke2xlbmd0aH0gIT0gJHtkYXRhLmJ5dGVMZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRW5jb2RlIGEgc3VwcG9ydGVkIHN0cnVjdHVyZSB0byBhIENCT1IgYnl0ZSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtlbmNvZGVDQk9SLCBDQk9SVHlwZSwgQ0JPUlRhZ30gZnJvbSAnLi9jYm9yLnRzJ1xuICogZW5jb2RlQ0JPUihuZXcgTWFwPHN0cmluZyB8IG51bWJlciwgQ0JPUlR5cGU+KFtcbiAqICAgW1wia2V5XCIsIFwidmFsdWVcIl0sXG4gKiAgIFsxLCBcImFub3RoZXIgdmFsdWVcIl1cbiAqIF0pKTtcbiAqIC8vIHJldHVybnMgbmV3IFVpbnQ4QXJyYXkoWzE2MiwgOTksIDEwNywgMTAxLCAxMjEsIDEwMSwgMTE4LCA5NywgMTA4LCAxMTcsIDEwMSwgMSwgMTA5LCA5NywgMTEwLCAxMTEsIDExNiwgMTA0LCAxMDEsIDExNCwgMzIgMTE4LCA5NywgMTA4LCAxMTcsIDEwMV0pXG4gKlxuICogZW5jb2RlQ0JPUihuZXcgQ0JPUlRhZygxMjM0LCBcImhlbGxvXCIpKVxuICogLy8gcmV0dXJucyBuZXcgVUludDhBcnJheShbMjE3LCA0LCAyMTAsIDEwMSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTFdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGRhdGEgRGF0YSB0byBlbmNvZGVcbiAqIEByZXR1cm5zIEEgYnl0ZSBzdHJpbmcgYXMgYSBVaW50OEFycmF5XG4gKiBAdGhyb3dzIEVycm9yXG4gKiAgIGlmIHVuc3VwcG9ydGVkIGRhdGEgaXMgZm91bmQgZHVyaW5nIGVuY29kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVDQk9SKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZW5jb2RlUGFydGlhbENCT1IoZGF0YSwgcmVzdWx0cyk7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG91dHB1dFtpbmRleF0gPSByZXN1bHQ7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnNldChyZXN1bHQsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAJOR_TYPE_ARRAY: () => (/* binding */ MAJOR_TYPE_ARRAY),\n/* harmony export */   MAJOR_TYPE_BYTE_STRING: () => (/* binding */ MAJOR_TYPE_BYTE_STRING),\n/* harmony export */   MAJOR_TYPE_MAP: () => (/* binding */ MAJOR_TYPE_MAP),\n/* harmony export */   MAJOR_TYPE_NEGATIVE_INTEGER: () => (/* binding */ MAJOR_TYPE_NEGATIVE_INTEGER),\n/* harmony export */   MAJOR_TYPE_SIMPLE_OR_FLOAT: () => (/* binding */ MAJOR_TYPE_SIMPLE_OR_FLOAT),\n/* harmony export */   MAJOR_TYPE_TAG: () => (/* binding */ MAJOR_TYPE_TAG),\n/* harmony export */   MAJOR_TYPE_TEXT_STRING: () => (/* binding */ MAJOR_TYPE_TEXT_STRING),\n/* harmony export */   MAJOR_TYPE_UNSIGNED_INTEGER: () => (/* binding */ MAJOR_TYPE_UNSIGNED_INTEGER),\n/* harmony export */   decodeLength: () => (/* binding */ decodeLength),\n/* harmony export */   encodeLength: () => (/* binding */ encodeLength)\n/* harmony export */ });\nfunction decodeLength(data, argument, index) {\n    if (argument < 24) {\n        return [argument, 1];\n    }\n    const remainingDataLength = data.byteLength - index - 1;\n    const view = new DataView(data.buffer, index + 1);\n    let output;\n    let bytes = 0;\n    switch (argument) {\n        case 24: {\n            if (remainingDataLength > 0) {\n                output = view.getUint8(0);\n                bytes = 2;\n            }\n            break;\n        }\n        case 25: {\n            if (remainingDataLength > 1) {\n                output = view.getUint16(0, false);\n                bytes = 3;\n            }\n            break;\n        }\n        case 26: {\n            if (remainingDataLength > 3) {\n                output = view.getUint32(0, false);\n                bytes = 5;\n            }\n            break;\n        }\n        case 27: {\n            if (remainingDataLength > 7) {\n                const bigOutput = view.getBigUint64(0, false);\n                // Bound it to [24, MAX_SAFE_INTEGER], where it is safe\n                // to encode as a javascript number\n                if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {\n                    return [Number(bigOutput), 9];\n                }\n            }\n            break;\n        }\n    }\n    if (output && output >= 24) {\n        return [output, bytes];\n    }\n    throw new Error(\"Length not supported or not well formed\");\n}\nconst MAJOR_TYPE_UNSIGNED_INTEGER = 0;\nconst MAJOR_TYPE_NEGATIVE_INTEGER = 1;\nconst MAJOR_TYPE_BYTE_STRING = 2;\nconst MAJOR_TYPE_TEXT_STRING = 3;\nconst MAJOR_TYPE_ARRAY = 4;\nconst MAJOR_TYPE_MAP = 5;\nconst MAJOR_TYPE_TAG = 6;\nconst MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;\nfunction encodeLength(major, argument) {\n    const majorEncoded = major << 5;\n    if (argument < 0) {\n        throw new Error(\"CBOR Data Item argument must not be negative\");\n    }\n    // Convert to bigint first.\n    // Encode integers around and above 32 bits in big endian / network byte order\n    // is unreliable in javascript.\n    // https://tc39.es/ecma262/#sec-bitwise-shift-operators\n    // Bit shifting operations result in 32 bit signed numbers\n    let bigintArgument;\n    if (typeof argument == \"number\") {\n        if (!Number.isInteger(argument)) {\n            throw new Error(\"CBOR Data Item argument must be an integer\");\n        }\n        bigintArgument = BigInt(argument);\n    }\n    else {\n        bigintArgument = argument;\n    }\n    // Negative 0 is not a thing\n    if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {\n        if (bigintArgument == 0n) {\n            throw new Error(\"CBOR Data Item argument cannot be zero when negative\");\n        }\n        bigintArgument = bigintArgument - 1n;\n    }\n    if (bigintArgument > 18446744073709551615n) {\n        throw new Error(\"CBOR number out of range\");\n    }\n    // Encode into 64 bits and extract the tail\n    const buffer = new Uint8Array(8);\n    const view = new DataView(buffer.buffer);\n    view.setBigUint64(0, bigintArgument, false);\n    if (bigintArgument <= 23) {\n        return [majorEncoded | buffer[7]];\n    }\n    else if (bigintArgument <= 255) {\n        return [majorEncoded | 24, buffer[7]];\n    }\n    else if (bigintArgument <= 65535) {\n        return [majorEncoded | 25, ...buffer.slice(6)];\n    }\n    else if (bigintArgument <= 4294967295) {\n        return [\n            majorEncoded | 26,\n            ...buffer.slice(4),\n        ];\n    }\n    else {\n        return [\n            majorEncoded | 27,\n            ...buffer,\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3JfaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkeVxcRGVza3RvcFxcZ2l0aHViY29waWxvdFxcTlVTLUlTUy1BSS1TRExDLUdyb3VwMS1Ub0RvQXBwXFxub2RlX21vZHVsZXNcXEBsZXZpc2NodWNrXFx0aW55LWNib3JcXGVzbVxcY2JvclxcY2Jvcl9pbnRlcm5hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGlmIChhcmd1bWVudCA8IDI0KSB7XG4gICAgICAgIHJldHVybiBbYXJndW1lbnQsIDFdO1xuICAgIH1cbiAgICBjb25zdCByZW1haW5pbmdEYXRhTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIC0gaW5kZXggLSAxO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIsIGluZGV4ICsgMSk7XG4gICAgbGV0IG91dHB1dDtcbiAgICBsZXQgYnl0ZXMgPSAwO1xuICAgIHN3aXRjaCAoYXJndW1lbnQpIHtcbiAgICAgICAgY2FzZSAyNDoge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI1OiB7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB2aWV3LmdldFVpbnQxNigwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNjoge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6IHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZ091dHB1dCA9IHZpZXcuZ2V0QmlnVWludDY0KDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBCb3VuZCBpdCB0byBbMjQsIE1BWF9TQUZFX0lOVEVHRVJdLCB3aGVyZSBpdCBpcyBzYWZlXG4gICAgICAgICAgICAgICAgLy8gdG8gZW5jb2RlIGFzIGEgamF2YXNjcmlwdCBudW1iZXJcbiAgICAgICAgICAgICAgICBpZiAoYmlnT3V0cHV0ID49IDI0biAmJiBiaWdPdXRwdXQgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtOdW1iZXIoYmlnT3V0cHV0KSwgOV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG91dHB1dCAmJiBvdXRwdXQgPj0gMjQpIHtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXQsIGJ5dGVzXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG5vdCBzdXBwb3J0ZWQgb3Igbm90IHdlbGwgZm9ybWVkXCIpO1xufVxuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfVU5TSUdORURfSU5URUdFUiA9IDA7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSID0gMTtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX0JZVEVfU1RSSU5HID0gMjtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX1RFWFRfU1RSSU5HID0gMztcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX0FSUkFZID0gNDtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX01BUCA9IDU7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9UQUcgPSA2O1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfU0lNUExFX09SX0ZMT0FUID0gNztcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVMZW5ndGgobWFqb3IsIGFyZ3VtZW50KSB7XG4gICAgY29uc3QgbWFqb3JFbmNvZGVkID0gbWFqb3IgPDwgNTtcbiAgICBpZiAoYXJndW1lbnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1IgRGF0YSBJdGVtIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRvIGJpZ2ludCBmaXJzdC5cbiAgICAvLyBFbmNvZGUgaW50ZWdlcnMgYXJvdW5kIGFuZCBhYm92ZSAzMiBiaXRzIGluIGJpZyBlbmRpYW4gLyBuZXR3b3JrIGJ5dGUgb3JkZXJcbiAgICAvLyBpcyB1bnJlbGlhYmxlIGluIGphdmFzY3JpcHQuXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1iaXR3aXNlLXNoaWZ0LW9wZXJhdG9yc1xuICAgIC8vIEJpdCBzaGlmdGluZyBvcGVyYXRpb25zIHJlc3VsdCBpbiAzMiBiaXQgc2lnbmVkIG51bWJlcnNcbiAgICBsZXQgYmlnaW50QXJndW1lbnQ7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1IgRGF0YSBJdGVtIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBiaWdpbnRBcmd1bWVudCA9IEJpZ0ludChhcmd1bWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiaWdpbnRBcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSAwIGlzIG5vdCBhIHRoaW5nXG4gICAgaWYgKG1ham9yID09IE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUikge1xuICAgICAgICBpZiAoYmlnaW50QXJndW1lbnQgPT0gMG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1IgRGF0YSBJdGVtIGFyZ3VtZW50IGNhbm5vdCBiZSB6ZXJvIHdoZW4gbmVnYXRpdmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYmlnaW50QXJndW1lbnQgPSBiaWdpbnRBcmd1bWVudCAtIDFuO1xuICAgIH1cbiAgICBpZiAoYmlnaW50QXJndW1lbnQgPiAxODQ0Njc0NDA3MzcwOTU1MTYxNW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBudW1iZXIgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgaW50byA2NCBiaXRzIGFuZCBleHRyYWN0IHRoZSB0YWlsXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NCgwLCBiaWdpbnRBcmd1bWVudCwgZmFsc2UpO1xuICAgIGlmIChiaWdpbnRBcmd1bWVudCA8PSAyMykge1xuICAgICAgICByZXR1cm4gW21ham9yRW5jb2RlZCB8IGJ1ZmZlcls3XV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZ2ludEFyZ3VtZW50IDw9IDI1NSkge1xuICAgICAgICByZXR1cm4gW21ham9yRW5jb2RlZCB8IDI0LCBidWZmZXJbN11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChiaWdpbnRBcmd1bWVudCA8PSA2NTUzNSkge1xuICAgICAgICByZXR1cm4gW21ham9yRW5jb2RlZCB8IDI1LCAuLi5idWZmZXIuc2xpY2UoNildO1xuICAgIH1cbiAgICBlbHNlIGlmIChiaWdpbnRBcmd1bWVudCA8PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYWpvckVuY29kZWQgfCAyNixcbiAgICAgICAgICAgIC4uLmJ1ZmZlci5zbGljZSg0KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYWpvckVuY29kZWQgfCAyNyxcbiAgICAgICAgICAgIC4uLmJ1ZmZlcixcbiAgICAgICAgXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.CBORTag),\n/* harmony export */   decodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor/cbor.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkeVxcRGVza3RvcFxcZ2l0aHViY29waWxvdFxcTlVTLUlTUy1BSS1TRExDLUdyb3VwMS1Ub0RvQXBwXFxub2RlX21vZHVsZXNcXEBsZXZpc2NodWNrXFx0aW55LWNib3JcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ0JPUlRhZywgZGVjb2RlQ0JPUiwgZGVjb2RlUGFydGlhbENCT1IsIGVuY29kZUNCT1IsIH0gZnJvbSBcIi4vY2Jvci9jYm9yLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js\n");

/***/ })

};
;